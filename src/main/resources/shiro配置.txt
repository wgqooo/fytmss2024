package com.fytmss.config;

import com.fytmss.filter.ClearSessionCacheFilter;
import com.fytmss.filter.KickoutSessionFilter;
import com.fytmss.realm.FyRealm;
import jakarta.servlet.Filter;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.cache.ehcache.EhCacheManager;
import org.apache.shiro.session.SessionListener;
import org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler;
import org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO;
import org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator;
import org.apache.shiro.session.mgt.eis.SessionDAO;
import org.apache.shiro.session.mgt.eis.SessionIdGenerator;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.CookieRememberMeManager;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.apache.shiro.web.servlet.SimpleCookie;
import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.beans.factory.config.MethodInvokingFactoryBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Base64;

/**
 * @author wgq
 * @create 2024/5/17-周五 10:38
 */
@Configuration
public class ShiroConfig {

    // todo 存疑？？？？？？？？？？？？
//    @Bean
//    public MethodInvokingFactoryBean getMethodInvokingFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager) {
//        MethodInvokingFactoryBean factoryBean = new MethodInvokingFactoryBean();
//        factoryBean.setStaticMethod("org.apache.shiro.SecurityUtils.setSecurityManager");
//        factoryBean.setArguments(new Object[]{defaultWebSecurityManager});
//        return factoryBean;
//    }


    /**
     * shiro 是支持缓存功能的，它可以对用户的授权数据和认证数据进行缓存，使得用户不必每次认证或授权时都去查询数据库
     * @return ehCacheManager需要添加到securityManager中
     */
    @Bean
    public EhCacheManager ehCacheManager(){
        EhCacheManager ehCacheManager = new EhCacheManager();
        ehCacheManager.setCacheManagerConfigFile("classpath:ehcache.xml");
        return ehCacheManager;
    }

    @Bean
    public ShiroSessionListener shiroSessionListener(){
        return new ShiroSessionListener();
    }

    @Bean
    public SessionIdGenerator sessionIdGenerator() {
        return new JavaUuidSessionIdGenerator();
    }

    @Bean
    public SessionDAO sessionDAO() {
        EnterpriseCacheSessionDAO sessionDAO = new EnterpriseCacheSessionDAO();
        sessionDAO.setCacheManager(ehCacheManager());
        sessionDAO.setActiveSessionsCacheName("shiro-activeSessionCache");
        sessionDAO.setSessionIdGenerator(sessionIdGenerator());
        return sessionDAO;
    }

    /**
     *
     * @return 注意：这里的cookie 不是记住我 cookie 记住我需要一个cookie session管理 也需要自己的cookie
     */
    @Bean
    public SimpleCookie sessionIdCookie(){
        // 这个参数是cookie的名称
        SimpleCookie simpleCookie = new SimpleCookie("sid");
        // setcookie的httponly属性如果设为true的话，会增加对xss防护的安全系数。它有以下特点：
        // 设为true后，只能通过http访问，javascript无法访问， 防止xss读取cookie
        simpleCookie.setHttpOnly(true);
        simpleCookie.setPath("/");
        // maxAge=-1表示浏览器关闭时失效此Cookie
        simpleCookie.setMaxAge(-1);
        return simpleCookie;
    }

    @Bean
    public ClearSessionCacheFilter clearSessionCacheFilter() {
        ClearSessionCacheFilter clearSessionCacheFilter = new ClearSessionCacheFilter();
        return clearSessionCacheFilter;
    }



    /**
     * session会话验证调度器
     * @return session会话验证调度器
     */
//    @Bean
//    public ExecutorServiceSessionValidationScheduler getConfigSessionValidationScheduler() {
//        ExecutorServiceSessionValidationScheduler sessionValidationScheduler = new ExecutorServiceSessionValidationScheduler();
//        //设置session的失效扫描间隔，单位为毫秒
//        sessionValidationScheduler.setInterval(10*60*1000);
//        return sessionValidationScheduler;
//    }

    /**
     * Session Manager：会话管理
     * 即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；
     * 会话可以是普通JavaSE环境的，也可以是如Web环境的；
         会话管理：https://cloud.tencent.cn/developer/article/1367252?from=15425
     */
    @Bean
    public DefaultWebSessionManager defaultWebSessionManager(){
        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();
        //取消url 后面的 JSESSIONID
        sessionManager.setSessionIdUrlRewritingEnabled(false);
        Collection<SessionListener> listeners = new ArrayList<SessionListener>();
        //配置监听
        listeners.add(shiroSessionListener());
        sessionManager.setSessionIdCookieEnabled(true);
        sessionManager.setSessionListeners(listeners);
        sessionManager.setSessionIdCookie(sessionIdCookie());
        sessionManager.setSessionDAO(sessionDAO());
        sessionManager.setCacheManager(ehCacheManager());
        //全局会话超时时间（单位毫秒），默认30分钟  暂时设置为10秒钟 用来测试
        //设置过长可能会导致安全隐患（如会话被劫持），设置过短则可能影响用户体验（用户频繁需要重新登录
        //3000000
        sessionManager.setGlobalSessionTimeout(1000 * 60 * 30);
        //是否开启删除无效的session对象  默认为true
        sessionManager.setDeleteInvalidSessions(true);
        //是否开启定时调度器进行检测过期session 默认为true
        sessionManager.setSessionValidationSchedulerEnabled(true);
        //设置session失效的扫描时间, 清理用户直接关闭浏览器造成的孤立会话 默认为 1个小时
        //设置该属性 就不需要设置 ExecutorServiceSessionValidationScheduler 底层也是默认自动调用ExecutorServiceSessionValidationScheduler
        //暂时设置为 5秒 用来测试
        sessionManager.setSessionValidationInterval(1000 * 60 * 60);

        //TODO 后续是否需要配置sessionDAO
        return sessionManager;
    }


    /**
     *每当一个会话被创建或更新时，它的数据需要持久化到一个存储位置以便它能够被稍后的应用程序访问。
     *同样地， 当一个会话失效且不再被使用时，它需要从存储中删除以便会话数据存储空间不会被耗尽。
     *SessionManager 实现委 托这些 Create/Read/Update/Delete(CRUD)操作为内部组件，
     *同时，SessionDAO，反映了数据访问对象（DAO）设计 模式。
     *SessionDAO 的权力是你能够实现该接口来与你想要的任何数据存储进行通信。
     *这意味着你的会话数据可以驻留在内存中，文件系统，关系数据库或 NoSQL 的数据存储，或其他任何你需要的位置。你得控制持久性行为。
     */

    /**
     * 开启Shiro注解(如@RequiresRoles,@RequiresPermissions),
     * 切面Advisor是切点和增强的复合体，Advisor本身已经包含了足够的信息，如横切逻辑以及连接点
     * DefaultAdvisorAutoProxyCreator能偶扫描Advisor，并将Advisor自动织入匹配的目标Bean中，为匹配的目标Bean自动创建代理
     * 需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证
     * @return creator
     */
    @Bean
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator(){
        DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator();
        creator.setProxyTargetClass(true);
        return creator;
    }

    /**
     * 开启aop注解支持
     * @return advisor
     */
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(){
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(defaultWebSecurityManager());
        return advisor;
    }

    @Bean
    public RetryLimitCredentialsMatcher getRetryLimitCredentialsMatcher(){
        RetryLimitCredentialsMatcher matcher = new RetryLimitCredentialsMatcher(ehCacheManager(), "loginRetryCache");
        //matcher就是用来指定加密规则
        //加密方式
        matcher.setHashAlgorithmName("SHA-256");
        //是Hex编码的还是Base64编码的。对应SimpleHash的toHex()和toBase64()
        matcher.setStoredCredentialsHexEncoded(true);
        //hash次数（对密码进行加密几次？）
        matcher.setHashIterations(3);
        return matcher;
    }

    @Bean
    public FyRealm fyRealm(){
        FyRealm fyRealm = new FyRealm();
        fyRealm.setCredentialsMatcher(getRetryLimitCredentialsMatcher());
        /* 开启支持缓存，需要配置如下几个参数 */
        fyRealm.setCachingEnabled(true);
        // 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false
        fyRealm.setAuthenticationCachingEnabled(true);
        // 缓存AuthenticationInfo信息的缓存名称 在 ehcache-shiro.xml 中有对应缓存的配置
        fyRealm.setAuthenticationCacheName("authenticationCache");
        // 启用授权缓存，即缓存AuthorizationInfo信息，默认false
        fyRealm.setAuthorizationCachingEnabled(true);
        // 缓存AuthorizationInfo 信息的缓存名称  在 ehcache-shiro.xml 中有对应缓存的配置
        fyRealm.setAuthorizationCacheName("authorizationCache");
        return fyRealm;
    }

    /**
     * rememberMeManager()方法是生成rememberMe管理器，而且要将这个rememberMe管理器设置到securityManager中
     * @return cookie管理对象;
     */
    @Bean
    public SimpleCookie rememberMeCookie(){
        // 这个参数是 cookie 的名称，叫什么都行,我这块取名 rememberMe
        SimpleCookie simpleCookie = new SimpleCookie("rememberMe");
        // setcookie 的 httponly 属性如果设为 true 的话，会增加对 xss 防护的安全系数，
        // 只能通过http访问，javascript无法访问，防止xss读取cookie
        simpleCookie.setHttpOnly(true);
        simpleCookie.setPath("/");
        // 记住我 cookie 生效时间30天 ,单位是秒
        simpleCookie.setMaxAge(2592000);
        return simpleCookie;
    }
    /**
     * cookie管理对象;记住我功能,rememberMe管理器
     * @return
     */
    @Bean
    public CookieRememberMeManager rememberMeManager(){
        CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager();
        cookieRememberMeManager.setCookie(rememberMeCookie());
        //rememberMe cookie加密的密钥 建议每个项目都不一样 默认AES算法 密钥长度(128 256 512 位)
        cookieRememberMeManager.setCipherKey(Base64.getDecoder().decode("4AvVhmFLUs0KTA3Kprsdag=="));
        return cookieRememberMeManager;
    }


    @Bean
    public DefaultWebSecurityManager defaultWebSecurityManager(){
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(fyRealm());
        // 将 EhCacheManager 注入到 SecurityManager 中，否则不会生效
        securityManager.setCacheManager(ehCacheManager());
        // 将 sessionManager 注入到 SecurityManager 中，否则不会生效
        securityManager.setSessionManager(defaultWebSessionManager());
        // 将 CookieRememberMeManager 注入到 SecurityManager 中，否则不会生效
        securityManager.setRememberMeManager(rememberMeManager());
        //ThreadContext.bind(securityManager);//加上这句代码手动绑定
        return securityManager;
    }

    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(){
        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();
        // Shiro的核心安全接口,这个属性是必须的
        shiroFilter.setSecurityManager(defaultWebSecurityManager());
        //不输入地址的话会自动寻找项目web项目的根目录下的/page/login.jsp页面
        //shiroFilter.setLoginUrl("/sys/login");
        //登录成功默认跳转页面，不配置则跳转至”/”。如果登陆前点击的一个需要登录的页面，则在登录自动跳转到那个需要登录的页面。不跳转到此。
       // shiroFilter.setSuccessUrl("/");
        // 自定义拦截器限制并发人数
        LinkedHashMap<String, Filter> filtersMap = new LinkedHashMap<>();
        //  todo 限制同一帐号同时在线的个数
        filtersMap.put("kickout", kickoutSessionControlFilter());
        // todo 拦截session过期的操作
       //filtersMap.put("clearSession", clearSessionCacheFilter());
        shiroFilter.setFilters(filtersMap);
        Map<String, String> map = new LinkedHashMap<>();
        // 不能对login方法进行拦截，若进行拦截的话，这辈子都登录不上去了,这个login是LoginController里面登录校验的方法
        map.put("/sys/**", "anon");
        //没做权限之前，要不先这样？HHHHH
        map.put("/webSocket/**", "anon");
        map.put("/base/**", "anon");
        map.put("/voyage/**", "anon");
        map.put("/ticket/**", "anon");
        map.put("/query/**", "anon");
        map.put("/finance/**", "anon");
        map.put("/static/**", "authc");
        //对所有用户认证
        //表示 访问 /** 下的资源首先要通过 kickout 对应的 filter 拦截处理下，然后再通过 authc 后面对应的 filter 才可以访问。
       // map.put("/**", "kickout,authc");
        map.put("/**", "authc");
        shiroFilter.setFilterChainDefinitionMap(map);
        return shiroFilter;
    }

    /**
     * 并发登录控制
     *  将kickoutSessionControlFilter的代码，移到ShiroFilterFactoryBean的bean代码后面就行？
     * @return
     */
    @Bean
    public KickoutSessionFilter kickoutSessionControlFilter() {
        KickoutSessionFilter kickoutSessionControlFilter = new KickoutSessionFilter();
        // 用于根据会话ID，获取会话进行踢出操作的；
        kickoutSessionControlFilter.setSessionManager(defaultWebSessionManager());
        // 使用cacheManager获取相应的cache来缓存用户登录的会话；用于保存用户—会话之间的关系的；
        kickoutSessionControlFilter.setCacheManager(ehCacheManager());
        // 是否踢出后来登录的，默认是false；即后者登录的用户踢出前者登录的用户；
        kickoutSessionControlFilter.setKickoutAfter(false);
        // 同一个用户最大的会话数，默认1；比如2的意思是同一个用户允许最多同时两个人登录；
        kickoutSessionControlFilter.setMaxSession(1);
        // 被踢出后重定向到的地址；
        kickoutSessionControlFilter.setKickoutUrl("/");
        return kickoutSessionControlFilter;
    }
}
